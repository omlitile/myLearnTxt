一，静态代理
    静态代理，由程序员创建或特定工具自动生成源代码，在编译时已经将接口，被代理类（委托类），代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。

二，动态代理：
    代理类在程序运行时常见的代理方式被称为动态代理。
    ①jdk动态代理：
    不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理

    ②cglib动态代理：
    可以代理没有实现接口的类。
    CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用， 例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。
    CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉

    ③对比：
    可以看到cglib的代理方式不需要传入被代理对象实例即可完成动态代理。
    cglib和jdk代理有什么区别呢？
    jdk的代理对象与被代理对象实现了同一接口,底层通过clone()方法,将实现类的方法复制过来在按照invoke中的配置对方法进行增强。
    而cglib代理则是代理对象继承了被代理对象的方法,然后自身进行增强。这两种代理思想在外来的自动生成代码方向会经常被使用,实现完全体代码的复用性。

三，三者对比
    ①静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件
    ②静态代理实现简单，但只能为一个目标对象服务。如果目标对象过多，则会产生很多代理类
    ③JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口

    ④JDK动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中
    而JDK动态代理须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。

    ⑤cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类

    ⑥cglib代理的对象无需实现接口，达到代理类无侵入

